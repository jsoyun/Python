#dp (중복하위문제일때 쓴다. 중복된
# 애들을 다시 계산하지 않고
# 메모리에 저장된 애들쓰자)

#1.크고 복잡한 문제를 작은 문제로 나눈다.
#2. 하위 문제의 답을 계산한다. 
#중복계산해야하는 하위문제가 있다.
#한번 계산한 결과를 메모리에 저장해서 재계산하지 않도록한다. 
#optimal substructure최적부분구조
#하위문제에 대한 답들을 통해 원래
# 문제에 대한 답을 계산한다.


#그 예시가 피보나치 수열!!
# 시작복잡도가 o(n)
# 메모리, 딕셔너리 나 리스트 써도됨
# 메모리에 적혀있는데로 반환할거임

# //재귀//1. top down 접근방식코드
# 탑다운이긴 한데 결국 하위부터 더한 값 저장해서 
memo = {}
def fibo(n):
    if n == 1 or n ==2:
        return 1
    if n not in memo:
        memo[n] = fibo(n-1) + fibo(n-2)
    return memo[n]
# ///for loop//2. Bottom up 접근방식

#베이스(그냥더하는하위값) 케이스 코드 적어놔야함.
#키와 값임 (피보니차리서 첫번째1,두번째1 )
memo = {1:1,2:1}
def fibo(n):

    for i in range(3,n+1):
        memo[i]= memo[i-1] + memo[i-2]
    return memo[n]

